#include "icartdaq/Generators/CAEN2795.hh"
#include "artdaq/Application/GeneratorMacros.hh"

#include <iomanip>
#include <iterator>
#include <iostream>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>


#define PBLT_SIZE     (61440)                     // in byte
#define RECORD_LENGTH (4*1024)                    // waveform length (in samples)
#define EVENT_SIZE    ((RECORD_LENGTH * 32) + 3)  // Event Size in lwords
#define NEV_READ      (1)                         // num of event to read with one BLT
#define BUFFER_SIZE   (EVENT_SIZE * NEV_READ)     // readout buffer size

icarus::CAEN2795::CAEN2795(fhicl::ParameterSet const & ps)
  :
  CAEN2795_GeneratorBase(ps)
{
  InitializeHardware();
}


CAENComm_ErrorCode icarus::CAEN2795::OpenOpticalLink(int const& node){
  
  auto ret = CAENComm_OpenDevice(CAENComm_OpticalLink, 0, node, 0, &LinkHandle[node]);

  if (ret != CAENComm_Success) 
    throw cet::exception("CAEN2795::InitializeHardware")
      << "Error opening the optical node " << node;
  else
    {
      std::cout << "After OpenDevice. Ret was success!  " << ret << std::endl;
      LinkInit[node] = 1;
    }

  return ret;
}

CAENComm_ErrorCode icarus::CAEN2795::AlignTTLink(){
  return CAENComm_Write32(LinkHandle[0], A_Signals, SIGNALS_TTLINK_ALIGN);
}

void icarus::CAEN2795::InitializeHardware(){

  LinkHandle.resize(nBoards_,0);
  LinkInit.resize(nBoards_,0);

  // note: node 0 is always the master.
  // Nodes are numbered after that according to daisy-chain.
  for(unsigned int i_b=0; i_b<nBoards_; ++i_b)
    OpenOpticalLink(i_b);

  AlignTTLink();

  usleep(100);
}

bool icarus::CAEN2795::IsRunning(){
  unsigned int data;
  auto ret = CAENComm_Read32(LinkHandle[0], A_ControlReg, &data);
  if( (data & CTRL_ACQRUN)==0 ) 
    return false;
  else 
    return true;
}

CAENComm_ErrCode icarus::CAEN2795::SetAcqRun(){
  return CAENComm_Write32(LinkHandle[0], A_ControlReg_Set, CTRL_ACQRUN);
}
CAENComm_ErrCode icarus::CAEN2795::ClearAcqRun(){
  return CAENComm_Write32(LinkHandle[0], A_ControlReg_Clear, CTRL_ACQRUN);
}

void icarus::CAEN2795::ConfigureStart(){

  if(!LinkInit[0])
    OpenOpticalLink(0);

  int loc_conet_node = 0;
  //int loc_conet_handle;
  int ret;
  unsigned int data;
  //unsigned int data_ap;
  
    usleep(100);
    
    // leggo se il master è già in run per decidere se dare SOR o EOR
    CAENComm_Read32(LinkHandle[0], A_StatusReg, &data);
    
    //data_ap = (data & STATUS_RUNNING);
    
    if ((data & STATUS_RUNNING) == 0){
      // Start Acq
      CAENComm_Write32(LinkHandle[0], A_Signals, SIGNALS_TTLINK_SOR);  
      printf("\nTTLink SOR...\n");
    }
    else{
      CAENComm_Write32(LinkHandle[0], A_Signals, SIGNALS_TTLINK_EOR);  
      printf("\nTTLink EOR...\n");
    }
    CAENComm_Read32(LinkHandle[0], A_StatusReg, &data);
    //data_ap = (data & STATUS_RUNNING);
    
  }
  
  usleep(100);



  engine_ = std::mt19937(ps_.get<int64_t>("random_seed", 314159));
  uniform_distn_.reset(new std::uniform_int_distribution<int>(0, std::pow(2,metadata_.num_adc_bits() - 1 )));
  std::cout << "CONFIGURED FAKE DATA GENERATOR." << std::endl;
}

void icarus::CAEN2795FakeData::ConfigureStop(){}

int icarus::CAEN2795FakeData::GetData(size_t & data_size, uint32_t* data_loc){

  data_size=0;

  for(size_t i_b=0; i_b<metadata_.num_boards(); ++i_b){
    size_t offset = i_b*(2+metadata_.channels_per_board()*metadata_.samples_per_channel()/2);
    data_loc[offset]   = (metadata_.event_number() & 0xffffff);
    data_loc[offset+1] = metadata_.event_number()+100;
    std::generate_n((uint16_t*)(&(data_loc[offset+2])),
		    metadata_.channels_per_board()*metadata_.samples_per_channel(),
		    [&](){ return static_cast<uint16_t>((*uniform_distn_)( engine_)); });
    data_size += (metadata_.channels_per_board()*metadata_.samples_per_channel()/2 + 2)*sizeof(uint32_t);
  }

  return 0;
}

DEFINE_ARTDAQ_COMMANDABLE_GENERATOR(icarus::CAEN2795FakeData) 
